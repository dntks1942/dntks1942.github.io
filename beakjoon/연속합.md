---
title: 연속합
tags: [Baekjun]
categories: [Baekjun]
---
# 연속합

걸린시간(분): 12
문제 번호: 1912
문제출처: https://www.acmicpc.net/problem/1912
복습: No
유형`: 다이나믹 프로그래밍
작성일시: 2023년 1월 9일 오후 8:10

# 연속합

전형적인 쉬운 다이나믹 프로그래밍 문제.

우선 수열에서 연속으로 가장 큰 배열을 찾아야 하므로 처음부터 끝까지 순서대로 주어진 수열을 탐색해야 한다. 이 과정에서 우리는 **매 수열에서 구해지는 최대 값과 최댓값이 될 수 있는 값을 저장해야 한다.**

이 때 최댓값이 될 수 있는 값은 뭘까?

최대 값이 될 수 있는 값은 현재는 최댓값 보다는 작지만 앞으로 나오는 수로 인해서 최댓값이 될 수 있는 수를 말한다. 그렇다면 우선 현재 값이 음수가 되어서 최댓값이 아닐지라도 뒤에 오는 수로 인해서 최댓값이 될 수 있으므로 모두 저장한다.

하지만 이 때 최댓값이 될 수 있는 값은 절대 음수가 나올 수는 없다. 왜냐하면 음수가 나와버리면 뒤에 어떠한 값을 더해도 뒤에서 시작한 값보다 클 수 없기 때문이다. 즉 **음수에 특정 수를 더한 값은 0에 특정 수를 더한 값 보다는 클 수 없다.**

## 해결방법

이를 고려하여 코딩을 하면 우선 입력 값을 저장할 배열, 최댓값을 저장할 배열, 최댓값이 될 수 있는 값을 저장할 배열의 3개의 배열이 필요하다.

그 후 전체 입력 값을 차례대로 살피면서 이전의 최댓값이 될 수 있는 값과 현재 값을 더하여 해당 값이 최댓값보다 큰 지를 비교해서 크면 최댓값을 변경하고 아니면 그대로 둔다. 이 과정에서 만약 이전의 최댓값이 될 수 있는 값이 음수이면 현재 최대 값이 될 수 있는 값은 0에서 현재 값을 더한 값, 즉 현재 값이 된다.

```cpp
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int number;
    cin >> number;
    vector<int> arr;   // 입력값 저장
    vector<int> dp;    // 최댓값이 될 수 있는 후보값
    vector<int> best;  // 최댓값
    arr.resize(number);
    dp.resize(number);
    best.resize(number);
		// 입력값 저장
    for(int i = 0; i < number; i++){
        cin >> arr[i];
    }
		// 가장 처음의 best, dp값 설정
    best[0] = arr[0]
    dp[0] = arr[0];
    for(int i = 1; i < number; i++){
        if(dp[i-1] < 0) dp[i] = arr[i];  // 이전 후보값이 음수이면 현재 후보값은 현재 입력값
        else dp[i] = dp[i-1] + arr[i];   // 이전 후보값이 양수이면 현재 후보값은 이전 후보값 + 현재 입력값
        if(dp[i] > best[i-1]) best[i] = dp[i];  // 이전 최댓값이 현재 후보값보다 작으면 현재 최댓값 갱신
        else best[i] = best[i-1];               // 이전 최댓값이 현재 후보값보다 크면 최댓값은 이전과 같다.
    }
    cout << best[number - 1];
}
```

# 결론

어제보다는 훨씬 잘 풀리는 것 같다. 역시 꾸준하게 계속 푸는 것이 가장 중요한 것 같다. DP의 전형적인 문제를 살펴보았다. 

앞으로 풀 DP문제도 이러한 형식을 기반으로 풀 수 있도록 노력이 필요.